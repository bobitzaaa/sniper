local function tryPurchase(uid, gems, item, playerid, buytimestamp)
    -- Așteaptă până când articolul este disponibil pentru cumpărare
    while workspace:GetServerTimeNow() < buytimestamp do
        task.wait()
    end

    -- Încercarea de a executa cumpărătura în mod sigur cu pcall
    local success, result = pcall(function()
        return rs.Network.Booths_RequestPurchase:InvokeServer(playerid, uid)
    end)

    if success then
        -- Verifică rezultatul cumpărăturii
        if result == true then
            print("Cumpărătura a fost realizată cu succes.")
        else
            warn("Cumpărătura nu a fost realizată: " .. tostring(result))
        end
    else
        warn("A apărut o eroare în timpul cumpărăturii: " .. tostring(result))
    end
end

-- Restul conexiunii evenimentului și a logicii rămân neschimbate.
-- ...
-- Continuare după funcția isItemAvailable și tryPurchase

Booths_Broadcast.OnClientEvent:Connect(function(username, message)
    if type(message) == "table" then
        for _, listing in pairs(message["Listings"] or {}) do
            if type(listing) == "table" and listing["ItemData"] and listing["ItemData"]["data"] then
                local data = listing["ItemData"]["data"]
                local gems = tonumber(listing["DiamondCost"])
                local uid = listing["UID"]
                local playerid = message['PlayerID']
                local buytimestamp = listing["ReadyTimestamp"]
                local item = data["id"]
                local class = tostring(listing["ItemData"]["class"])
                local unitGems = gems / (tonumber(data["_am"]) or 1)

                -- Utilizează funcția isItemAvailable pentru a verifica dacă itemul este disponibil
                if isItemAvailable(item) and unitGems <= 100000

