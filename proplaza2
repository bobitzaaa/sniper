local function attemptPurchase(uid, playerid, buytimestamp)
    -- Asigură-te că timpul de așteptare a trecut
    while workspace:GetServerTimeNow() < buytimestamp do
        task.wait()
    end

    -- Încercăm să cumpărăm itemul și prindem orice eroare
    local success, result = pcall(function()
        return rs.Network.Booths_RequestPurchase:InvokeServer(playerid, uid)
    end)

    if success then
        -- Dacă apelul a reușit, verificăm rezultatul achiziției
        if result == true then
            print("Achiziția a fost efectuată cu succes.")
        else
            -- Rezultatul achiziției nu a fost un succes, gestionează conform logicii jocului
            warn("Achiziția a eșuat cu mesajul: " .. tostring(result))
        end
    else
        -- Apelul a eșuat, gestionează eroarea
        warn("A apărut o eroare la apelul funcției de cumpărare: " .. tostring(result))
    end
end

Booths_Broadcast.OnClientEvent:Connect(function(username, message)
    if type(message) == "table" then
        for _, listing in pairs(message["Listings"] or {}) do
            if type(listing) == "table" and listing["ItemData"] and listing["ItemData"]["data"] then
                local data = listing["ItemData"]["data"]
                local gems = tonumber(listing["DiamondCost"])
                local uid = listing["UID"]
                local playerid = message['PlayerID']
                local buytimestamp = listing["ReadyTimestamp"]
                local item = data["id"]
                local class = tostring(listing["ItemData"]["class"])
                local unitGems = gems / (tonumber(data["_am"]) or 1)

                -- Utilizează funcția isItemAvailable pentru a verifica dacă itemul este disponibil
                if isItemAvailable(item) and unitGems <= 1000000 then -- Exemplu de limită a prețului
                    attemptPurchase(uid, playerid, buytimestamp)
                end
            end
        end
    end
end)
