local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local leaderstats = player:WaitForChild("leaderstats")
local diamonds = leaderstats:WaitForChild("Diamonds") -- Asumând că există un stat numit "Diamonds"
local Booths_Broadcast = ReplicatedStorage:WaitForChild("Network"):WaitForChild("Booths_Broadcast")
local maxGems = 100 -- Prețul maxim al articolului pe care ești dispus să-l plătești

local function tryPurchase(itemData)
    -- Aici ar trebui să adaugi logica pentru a cumpăra articolul
    -- Presupunem că avem o funcție 'purchaseItem' disponibilă pe partea de server
    local success, message = ReplicatedStorage.Network.Booths_RequestPurchase:InvokeServer(itemData.playerId, itemData.uid)
    
    if success then
        print("Articol cumpărat cu succes: " .. itemData.item)
    else
        warn("Eroare la cumpărarea articolului: " .. tostring(message))
    end
end

Booths_Broadcast.OnClientEvent:Connect(function(username, message)
    if type(message) == "table" and message["Listings"] then
        for _, listing in pairs(message["Listings"]) do
            if type(listing) == "table" and listing["ItemData"] and listing["ItemData"]["data"] then
                local itemData = listing["ItemData"]["data"]
                local gems = tonumber(listing["DiamondCost"])
                local uid = listing["UID"]
                local playerId = message['PlayerID']
                
                -- Verifică dacă prețul este sub 100 de gems și dacă jucătorul are suficiente gems
                if gems <= maxGems and diamonds.Value >= gems then
                    -- Așteaptă până când articolul este eligibil pentru cumpărare
                    repeat wait() until workspace:GetServerTimeNow() >= listing["ReadyTimestamp"] - player:GetNetworkPing()
                    -- Încearcă să cumpere articolul
                    tryPurchase({playerId = playerId, uid = uid, item = itemData["id"], gems = gems})
                end
            end
        end
    end
end)
